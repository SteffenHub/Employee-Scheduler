import time
from ortools.sat.python import cp_model
from ortools.sat.python.cp_model import CpSolverSolutionCallback
from prettytable import PrettyTable

from src.excel_interface import write_to_excel, read_from_excel
from src.model.ConsoleOutput import ConsoleOutput
from src.rule_builder import (add_every_shift_skill_is_assigned, add_one_employee_only_one_shift_per_day,
                              add_employee_cant_do_what_he_cant, add_employees_can_only_work_with_team_members,
                              add_one_employee_only_works_five_days_a_week,
                              add_one_employee_works_the_same_shift_a_week,
                              add_every_employee_have_two_shift_pause, add_shift_cycle,
                              add_at_least_one_shift_manager_per_team_per_day,
                              add_one_employee_only_works_five_days_in_a_row, add_employee_should_work_in_a_row,
                              add_employee_should_work_night_shifts_in_a_row,
                              add_every_employee_should_do_same_amount_night_shifts, add_illness,
                              add_one_employee_should_work_max_five_days_in_a_row, add_vacations,
                              add_one_employee_works_max_ten_days_in_a_row,
                              add_one_employee_should_work_max_ten_days_in_a_row,
                              add_every_employee_should_do_same_amount_of_shifts,
                              add_vac_not_in_ill, add_absence_manually, add_employee_works_night_shifts_in_a_row,
                              add_minimize_needed_skills, add_minimize_needed_employees)

from src.model.Input_data_creator import get_teams_input_data, get_weeks_input_data
from src.model.Team import Team
from src.model.Week import Week
from datetime import datetime


class CustomSolutionPrinter(CpSolverSolutionCallback):
    """
    CustomSolutionPrinter is a callback class used to iterate through and present solutions
    generated by the CpSolver in a human-readable format. This includes printing to the console
    using PrettyTable and writing results to an Excel file.

    It is designed to provide a detailed view of each solution including the teams, employees,
    their assigned values, and the computed costs.
    """
    def __init__(self, output: list[ConsoleOutput],
                 all_vars: dict[str, cp_model.IntVar],
                 teams: list[Team],
                 weeks: list[Week],
                 start_time: str):
        CpSolverSolutionCallback.__init__(self)
        self.output = output
        self.solution_count = 0
        self.start_time = time.time()
        self.all_vars = all_vars
        self.weeks = weeks
        self.teams = teams
        self.start_date_and_time: str = start_time

    def on_solution_callback(self) -> None:
        table = PrettyTable()
        self.solution_count += 1
        print(f"Solution {self.solution_count}, time {time.time() - self.start_time}s")

        # create and set column names
        field_names: list[str] = ["Team", "Employee"]
        for output_item in self.output:
            field_names.append(output_item.column_name)
            field_names.append(f"{output_item.column_name} cost")
        field_names.append("sum_costs")
        table.field_names = field_names

        # sum of all employees for each column(numbers in last row)
        sums_initial_columns: list[int] = [0 for _ in self.output]
        sums_cost_columns: list[int] = [0 for _ in self.output]

        for i, teamEmployee in enumerate(self.output[0].data.keys()):
            team, employee = teamEmployee.split(":")
            next_team = list(self.output[0].data.keys())[i + 1].split(":")[0] if i < len(
                self.output[0].data) - 1 else team
            is_last_empl_in_team: bool = len(self.output[0].data) == i + 1 or team != next_team

            # create one row, representing one employee
            row_data = [team, employee]
            all_cost_sum: int = 0
            for j, output_item in enumerate(self.output):
                value = self.Value(output_item.data[teamEmployee])
                initial = int(value / output_item.cost)
                objective_cost = value ** 2

                row_data.append(initial)
                sums_initial_columns[j] += initial

                row_data.append(objective_cost)
                all_cost_sum += objective_cost
                sums_cost_columns[j] += objective_cost

            row_data.append(all_cost_sum)
            table.add_row(row_data, divider=is_last_empl_in_team)

        # create and add last row containing the sum of all values above it
        last_row = ["sum costs", ""]
        for i in range(len(sums_initial_columns)):
            last_row.append(sums_initial_columns[i])
            last_row.append(sums_cost_columns[i])
        last_row.append(int(self.ObjectiveValue()))
        table.add_row(last_row)
        print(table)

        # write result to excel
        needed_keys = get_keys(self.weeks, self.teams)
        time_now = f"{time.time() - self.start_time}"
        solution = {var: self.Value(self.all_vars[var]) == 1 for var in self.all_vars.keys()}
        filtered_solution = {key: int_var for key, int_var in solution.items() if key in needed_keys}
        write_to_excel(filtered_solution, self.teams, self.weeks, ["M", "A", "N"],
                       f"../output_data/start_on_{self.start_date_and_time}",
                       f"scheduler_result_{time_now}.xlsx")


class MyAnalysisSolutionPrinter(CpSolverSolutionCallback):
    """
    The MyAnalysisSolutionPrinter class is a callback object for managing solver solutions.

    This class is designed to handle solutions provided by a CP-solver. It tracks the number of solutions found,
    measures the time taken for each solution, and logs the detailed results. The class leverages the solver's
    callback mechanism to process and store information about each solution, including writing specific data to
    text files and exporting results to an Excel file.
    """
    def __init__(self, data,
                 all_vars,
                 teams: list[Team],
                 weeks: list[Week]):
        CpSolverSolutionCallback.__init__(self)
        self.solution_count = 0
        self.start_time = time.time()
        self.data = data
        self.all_vars = all_vars
        self.weeks = weeks
        self.teams = teams

    def on_solution_callback(self) -> None:
        print(
            f"Solution {self.solution_count}, time {time.time() - self.start_time}s, objective {self.ObjectiveValue()}")
        self.solution_count += 1
        for empl, skills in self.data.items():
            print(f"{empl} : {[skill for skill, value in skills.items() if self.Value(value) == 1]}")
        time_now = f"{time.time() - self.start_time}"
        values_till_now = [f"{empl} : {[skill for skill, value in skills.items() if self.Value(value) == 1]}" for
                           empl, skills in self.data.items()]
        with open(f'output_{time_now}.txt', 'w') as f:
            for string in values_till_now:
                f.write(str(string) + '\n')
        with open(f'values_{time_now}.txt', 'w') as f:
            f.write(str(self.ObjectiveValue()))
        needed_keys = get_keys(self.weeks, self.teams)
        x = {var: self.Value(self.all_vars[var]) == 1 for var in self.all_vars.keys()}
        filtered_results = {key: int_var for key, int_var in x.items() if key in needed_keys}
        write_to_excel(filtered_results, self.teams, self.weeks, ["M", "A", "N"],
                       "../",
                       f"hello_world_{time_now}.xlsx")


def get_model(model: cp_model.CpModel,
              all_vars: dict[str, cp_model.IntVar],
              console_output: list[ConsoleOutput],
              teams: list[Team],
              weeks: list[Week],
              start_time: str,
              number_of_cores: int,
              stop_calc_after: float) -> dict[str, bool] | None:
    """
    Solves the provided constraint programming model using a custom solution printer and
    returns a dictionary mapping variable names to their boolean assignment if a feasible
    or optimal solution is found, else returns None.

    :param model: The constraint programming model to be solved.
    :type model: cp_model.CpModel
    :param all_vars: Dictionary mapping variable names to their corresponding IntVar objects.
    :type all_vars: dict[str, cp_model.IntVar]
    :param console_output: List of ConsoleOutput objects for handling output during solution search.
    :type console_output: list[ConsoleOutput]
    :param teams: List of teams participating in the scheduling model.
    :type teams: list[Team]
    :param weeks: List of weeks considered in the scheduling model.
    :type weeks: list[Week]
    :param start_time: The starting time for the solution search.
    :type start_time: str
    :param number_of_cores: Number of CPU cores to be utilized in parallel for solving the model.
    :type number_of_cores: int
    :param stop_calc_after: Time limit in seconds to stop the calculation after.
    :type stop_calc_after: float
    :return: A dictionary mapping variable names to boolean values if a solution is found, else None.
    :rtype: dict[str, bool] | None
    """
    solver = cp_model.CpSolver()
    solver.parameters.num_search_workers = number_of_cores
    solver.parameters.max_time_in_seconds = stop_calc_after
    status = solver.Solve(model, CustomSolutionPrinter(console_output, all_vars, teams, weeks, start_time))
    print("TIME LIMIT REACHED")
    if status in [cp_model.OPTIMAL, cp_model.FEASIBLE]:
        if status == cp_model.OPTIMAL:
            print("OPTIMAL")
        if status == cp_model.FEASIBLE:
            print("FEASIBLE")
        return {var: solver.Value(all_vars[var]) == 1 for var in all_vars.keys()}
    else:
        if status == cp_model.INFEASIBLE:
            print("INFEASIBLE")
        if status == cp_model.UNKNOWN:
            print("UNKNOWN")
        if status == cp_model.MODEL_INVALID:
            print("MODEL_INVALID")
        return None


def add_hard_constraints(model: cp_model.CpModel, all_vars:dict[str, cp_model.IntVar], weeks_plus_one: list[Week], teams: list[Team]):
    """
    Adds a set of predefined hard constraints to the given model. These constraints ensure that the employee
    scheduling adheres to the specified rules and conditions.

    :param model: The constraint programming model to which the constraints will be added.
    :type model: cp_model.CpModel
    :param all_vars: A dictionary containing all decision variables used in the model.
    :type all_vars: dict[str, cp_model.IntVar]
    :param weeks_plus_one: List of Week objects including an additional day to be sure the next week can be generated
    :type weeks_plus_one: list[Week]
    :param teams: A list of teams participating in the scheduling.
    :type teams: list[Team]
    :return: None
    :rtype: NoneType
    """
    add_every_shift_skill_is_assigned(model, weeks_plus_one, teams, all_vars)
    add_one_employee_only_one_shift_per_day(model, weeks_plus_one, teams, all_vars)
    add_employee_cant_do_what_he_cant(model, weeks_plus_one, teams, all_vars)
    add_employees_can_only_work_with_team_members(model, weeks_plus_one, teams, all_vars)
    add_one_employee_only_works_five_days_a_week(model, weeks_plus_one, teams, all_vars)
    add_one_employee_works_the_same_shift_a_week(model, weeks_plus_one, teams, all_vars)
    add_every_employee_have_two_shift_pause(model, weeks_plus_one, teams, all_vars)
    add_shift_cycle(model, weeks_plus_one, teams, all_vars, ["M", "A", "N"])
    add_at_least_one_shift_manager_per_team_per_day(model, weeks_plus_one, teams, all_vars)
    # add_one_employee_only_works_five_days_in_a_row(model, weeks_plus_one, teams, all_vars)
    # add_one_employee_works_max_ten_days_in_a_row(model, weeks_plus_one, teams, all_vars)
    # add_illness_manually(model, weeks, all_vars, "Team1_P5", [f"Week1_{day.name}" for day in weeks[0].days])
    # add_absence_manually(model, weeks, all_vars, "Team1_P6", [f"Week1_{day.name}" for day in weeks[0].days])
    # add_absence_manually(model, weeks, all_vars, "Team1_P6", [f"Week2_{day.name}" for day in weeks[0].days[:3]])
    # add_vacations(model, weeks, teams, all_vars, 5, 7)
    # add_illness(model, weeks, teams, all_vars, 5, 5)
    # add_vac_not_in_ill(model, weeks, teams, all_vars)
    # add_employee_works_night_shifts_in_a_row(model, weeks, teams, all_vars, "N")


def run(weeks: list[Week],
        weeks_plus_one: list[Week],
        teams: list[Team],
        true_keys: list[str],
        number_of_cores: int,
        stop_calc_after: float) -> tuple[dict[str, bool] | None, str]:
    """
    Runs the schedule optimization model for given weeks and teams with specified constraints.

    This function initializes the CPModel, creates variables required for the model, adds both
    hard and soft constraints, and then minimizes the combined cost based on various constraints
    like the number of works in a row, night shifts distribution, and shifts distribution among
    employees. Finally, it returns the result of the model and the start time of the solving process.

    :param weeks: List of Week objects representing the weeks for which the schedule
                  needs to be optimized.
    :type weeks: list[Week]
    :param weeks_plus_one: List of Week objects including an additional day to be sure the next week can be generated
    :type weeks_plus_one: list[Week]
    :param teams: List of Team objects representing the teams involved in the schedule
                  optimization.
    :type teams: list[Team]
    :param true_keys: List of string keys that are set to true in the model, representing
                      previously calculated shift schedules that should be retained.
    :type true_keys: list[str]
    :param number_of_cores: Integer representing the number of CPU cores to be utilized
                            for the optimization.
    :type number_of_cores: int
    :param stop_calc_after: Float representing the maximum time allowed for the calculation.
    :type stop_calc_after: float
    :return: A tuple containing the model result and the start time of the solving process.
    :rtype: tuple[dict[str, bool] | None, str]
    """
    # initialize the CPModel
    model = cp_model.CpModel()

    # create all vars
    all_vars: dict[str, cp_model.IntVar] = {}
    for key in get_keys(weeks_plus_one, teams):
        all_vars[key] = model.NewBoolVar(key)

    # If a previous calculated shift schedule read set the read keys to true
    for key in true_keys:
        model.Add(all_vars[key] == 1)

    # Add all Hard constraints
    add_hard_constraints(model, all_vars, weeks_plus_one, teams)

    # Soft constrains
    (minimize_var_work_in_row, transition_cost_per_employee) = \
        add_employee_should_work_in_a_row(model, weeks, teams, all_vars, 3)
    (minimize_var_work_in_row_at_night, night_transition_cost_per_employee) = \
        add_employee_should_work_night_shifts_in_a_row(model, weeks, teams, all_vars, 7 * 4 * 2, "N")
    (minimize_var_same_night_shift_amount_per_employee, night_shift_cost_per_employee) = \
        add_every_employee_should_do_same_amount_night_shifts(model, weeks, teams, all_vars, 10, "N")
    (minimize_var_same_shift_amount_per_employee, shift_cost_per_employee) = \
        add_every_employee_should_do_same_amount_of_shifts(model, weeks, teams, all_vars, 10)
    # add_an_employee_should_do_the_same_job_a_week(model, weeks, teams, all_vars)
    minimize_five_days_a_row, five_days_a_row_cost_per_employee = add_one_employee_should_work_max_five_days_in_a_row(
        model, weeks, teams, all_vars, 10000)
    # (minimize_ten_days_a_row, ten_days_a_row_cost_per_employee) = (
    #    add_one_employee_should_work_max_ten_days_in_a_row(model, weeks, teams, all_vars, 10000))
    # skills_employee, minimize_skills_cost = add_minimize_needed_skills(model, weeks, teams, all_vars, 1)
    # minimize_needed_empl = add_minimize_needed_employees(model, weeks, teams, all_vars, 100)
    # model.Minimize(minimize_needed_empl + minimize_skills_cost)

    # Minimize the sum of all cost
    model.Minimize(minimize_var_work_in_row +
                   minimize_var_work_in_row_at_night +
                   minimize_var_same_night_shift_amount_per_employee +
                   minimize_var_same_shift_amount_per_employee +
                   minimize_five_days_a_row)

    print("All Rules added. Start Solver")
    start_time: str = datetime.now().strftime("%Y-%m-%d_at_time_%H-%M-%S")
    model_result = get_model(model, all_vars,
                             [ConsoleOutput(column_name="transition", data=transition_cost_per_employee, cost=3),
                              ConsoleOutput(column_name="night transition", data=night_transition_cost_per_employee,
                                            cost=56),
                              ConsoleOutput(column_name="night shift distribution", data=night_shift_cost_per_employee,
                                            cost=10),
                              ConsoleOutput(column_name="shift distribution", data=shift_cost_per_employee, cost=10),
                              ConsoleOutput(column_name="overtime", data=five_days_a_row_cost_per_employee,
                                            cost=10000)],
                             teams, weeks,
                             start_time,
                             number_of_cores,
                             stop_calc_after)
    return model_result, start_time


def get_keys(weeks: list[Week], teams: list[Team]) -> list[str]:
    """
    Generate a list of keys based on the given weeks and teams.

    The function creates a series of keys that represent different shifts and
    needed skills for each employee in the provided teams, over the given weeks.
    Additionally, it generates keys for vacation and illness days.

    :param weeks: A list of Week objects to iterate over.
    :type weeks: list[Week]
    :param teams: A list of Team objects, each containing employees.
    :type teams: list[Team]
    :return: A list of generated keys as strings.
    :rtype: list[str]
    """
    keys: list[str] = []
    for team in teams:
        for employee in team.employees:
            for week in weeks:
                for day in week.days:
                    for shift in day.shifts:
                        for needed_skill in shift.needed_skills:
                            keys.append(f"{week}_{day}_{shift}_{team}_{employee}_{needed_skill}")
                    keys.append(f"{week}_{day}_vac_{team}_{employee}_vac")
                    keys.append(f"{week}_{day}_ill_{team}_{employee}_ill")

    return keys


def main(filename: str | None,
         how_many_days: int,
         number_of_cores: int,
         stop_calc_after: float):
    """
    Main entry point for running the scheduler application. Depending on the filename
    provided, it either reads from an existing Excel file or initializes a new input
    dataset. The function computes scheduling results based on teams' input data and
    the number of days provided and writes the results to a new Excel file.

    :param filename: The path to an existing Excel file to read input data. If None,
                     new input data will be generated.
    :type filename: str or None
    :param how_many_days: The number of days to schedule.
    :type how_many_days: int
    :param number_of_cores: The number of CPU cores to use for computation.
    :type number_of_cores: int
    :param stop_calc_after: The maximum time duration (in seconds) to run the calculation.
    :type stop_calc_after: float
    :return: None. The result is written to an Excel file.
    """
    if filename is not None:
        keys = read_from_excel(filename)
        highest_week_number = max([int(k.split('_')[0][4:]) for k in keys])
    else:
        keys = []
        highest_week_number = 0

    teams_input = get_teams_input_data()
    weeks_input_plus_one = get_weeks_input_data(highest_week_number * 7 + how_many_days + 1)
    weeks_input = get_weeks_input_data(highest_week_number * 7 + how_many_days)
    result, start_time = run(weeks=weeks_input,
                             weeks_plus_one=weeks_input_plus_one,
                             teams=teams_input,
                             true_keys=keys,
                             number_of_cores=number_of_cores,
                             stop_calc_after=stop_calc_after)
    needed_keys = get_keys(weeks_input, teams_input)
    filtered_result = {key: int_var for key, int_var in result.items() if key in needed_keys}

    if result is not None:
        write_to_excel(filtered_result, teams_input, weeks_input, ["M", "A", "N"],
                       f"../output_data/start_on_{start_time}",
                       "scheduler_result_final.xlsx")


if __name__ == "__main__":
    # If there exist a shift schedule from a previous calculation add its filename here
    # If file = None than the calculation starts with day1, no previous shift schedule given
    previous_calc_filename = None  # 'scheduler_result_final.xlsx'
    use_number_of_cores: int = 8
    stop_calculation_after: float = 1200.0
    days_to_calculate = 7 * 4  # 4 additional weeks to the previous calculation if previous_calc_file is not None
    main(previous_calc_filename, days_to_calculate, use_number_of_cores, stop_calculation_after)
